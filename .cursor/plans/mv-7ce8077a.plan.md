<!-- 7ce8077a-6de1-42c8-9465-4567c4063ab8 5be5615d-754e-4bc6-ac1e-daf7c1983a58 -->
# MVCC Read-Committed Plan

> Baseline + architecture reference: `docs/mvcc-baseline.md` (section numbers cited below).

## 1. Baseline Analysis

- **DONE ✅** catalog-current: Map the transaction boundaries and locking flow in `primitives/pager/pager.rs` plus `primitives/concurrency/mod.rs`; documentation now lives in `docs/mvcc-baseline.md` §§1–4.
- Textual call-flow write-up covers read-only, write, and checkpoint paths plus hook points for MVCC metadata injection.
- Mermaid sequence diagrams are published in `docs/mvcc-baseline.md` §11 so onboarding material matches the textual walkthrough.
- **DONE ✅** storage-current: Trace how commits propagate into higher layers (`storage/graph`, `storage/index`, `storage/vstore`) and identify mutable entry points that must learn about versioning metadata (`docs/mvcc-baseline.md` §6).
- Flow table catalogs each mutation path, touched structs, and guard usage; invariants (ID allocators, GraphWriter caching, adjacency batching) are noted as MVCC hooks.
- Provides the owner/component mapping required before adding version metadata plumbing.
- **DONE ✅** wal-current: Summarize WAL layout and LSN handling to understand where commit metadata and version pointers can live without breaking recovery (`docs/mvcc-baseline.md` §7).
- Header and frame layouts, CRC chaining, and metadata options are recorded so we know where slack exists.
- Crash/replay validation now has a concrete harness (`docs/mvcc-baseline.md` §12, `tests/integration/wal_crash_replay.rs`) to prove redo ordering and guide metadata-frame persistence.

## 2. MVCC Architecture Definition

- **SPEC ✅** mvcc-object-model: Choose the granularity for MVCC metadata (per-record vs per-page) and define headers/flags for node, edge, and property payloads (see `docs/mvcc-baseline.md` §8).
- Version envelope (`VersionHdr`) + `PageVersionInfo` chain structure documented with field sizes and structure-specific guidance.
- Trade-offs between per-record headers, adjacency/index duplication, and WAL replay materialization captured for later validation.
- **SPEC ✅** mvcc-timeline: Specify commit/visibility rules for read-committed while still using `SingleWriter`, issuing monotonically increasing commit IDs from the pager (`docs/mvcc-baseline.md` §9).
- Snapshot selection rules, tombstone semantics, and cascade/delete handling are defined; checkpoint interactions now key off commit table state instead of checkpoints alone.
- Recovery semantics (commit table transitions, ignoring uncommitted WAL frames) are laid out to guide pager changes.
- **SPEC ✅** mvcc-metadata-store: Design lightweight commit table/history (in-memory with WAL-backed redo) plus checkpoint integration (`docs/mvcc-baseline.md` §10).
- In-memory commit table shape, metadata WAL frames, and GC/retention workflow are described alongside metrics needed for observability.
- Cleanup/vacuum pacing ties oldest-reader tracking to WAL/pruning decisions; recovery flow reconstructs commit state from metadata frames.

## 3. Pager & Transaction Layer Enhancements

- **DONE ✅** pager-read-snap: Extend `ReadGuard` to pin to the latest committed LSN (not just last checkpoint) and teach `Pager::get_page` to materialize visible versions using WAL pages or version chain.
- Add explicit APIs to request “read-committed snapshot” and assert they reject attempts after guard drop; this clarifies lifetime rules.
- Prototype a fast path where WAL pages are replayed into a private buffer if the page is dirty but visible; benchmark the added copies (documented in `docs/mvcc-baseline.md` §13).
- **DONE ✅** pager-write-cow: Initial copy-on-write plumbing keeps committed page images in-memory via `Pager::cache_overlays` + `version_chains` so readers can pin historical data before checkpoint (`src/primitives/pager/pager.rs`).
- Instrumentation counters now expose retained version/page totals and version payloads are released according to the oldest active snapshot so COW pressure follows `min_active` progress.
- **DONE ✅** pager-version-tracking: Per-page chains backed by `version_chains` map now serve snapshots without WAL replay; cleanup hooks run during checkpoint via `prune_version_chains`.
- Version entries record WAL offsets and can rehydrate historical images directly from the WAL when cached data is dropped, so recovery and read servicing no longer require full WAL scans.

## 4. Storage Layer Adaptation

- storage-record-encode: Update node/edge/property encoders to include MVCC metadata fields with a clean file-format bump (no backward compatibility needed).
- Spell out the new record layout and drop any legacy decode branches—callers must rebuild or reimport existing data.
- Update fuzz/round-trip tests for record encoding so they assert version metadata survives compression/decompression.
- catalog-and-index: Ensure `storage/index/store.rs` and subordinate indexes only surface entries whose version is visible to the reader; plan for deferred index maintenance queues if needed.
- Identify each index access path (primary, secondary, property) and introduce helper filters that evaluate visibility predicates close to the data.
- Evaluate whether deferred index maintenance queue is necessary for deletes; specify queue durability requirements if so.
- write-workflows: Audit `GraphWriter`, `patch`, and vstore mutation paths so they register deletes/inserts as versioned tombstones instead of hard overwrites.
- Update mutation APIs to accept MVCC context (commit ID, visibility flags) and plumb through to physical encoders.
- Introduce consistency assertions ensuring we never mix committed + uncommitted versions within a single logical batch.

## 5. Garbage Collection & Vacuum

- reader-tracking: Instrument reader lifecycle to expose oldest active commit ID; publish via stats.
- Store tracking info in a lock-free structure keyed by guard handle so slow readers do not block writer progress unnecessarily.
- Emit debug logs or metrics when the gap between newest/oldest reader exceeds thresholds; helps tune vacuum frequency.
- vacuum-strategy: Sketch vacuum worker design (reuse `admin/vacuum.rs`) to prune obsolete versions after checkpoints, including fallbacks if vacuum lags.
- Define pacing algorithm (bytes/sec, pages per tick) and integration with IO budget controls.
- Determine how vacuum coordinates with WAL truncation to avoid double frees or dangling pointers.
- checkpoint-sync: Align checkpoint routine so it can drop WAL segments only after confirming no reader needs the versions they contain.
- Update checkpoint state machine diagrams to include MVCC hooks: verifying commit table, page-version reclamation, WAL segment drop.
- Add tests simulating long-running readers during checkpoint to ensure we never violate durability or visibility — commit-table retention tests in `src/storage/mvcc.rs` now cover snapshot pinning vs. vacuum horizon.

## 6. Testing & Tooling

- unit-tests: Add focused tests around version visibility (reader vs writer, deletes, updates) across pager and storage layers.
- Cover edge cases such as rapid writer churn, nested mutations, and read guards that outlive writer drop.
- Include WAL recovery tests to ensure version metadata replays correctly even when mid-transaction crash occurred.
- integration-tests: Create multi-step scenarios (e.g., concurrent graph traversals) ensuring read-committed semantics hold without checkpoints.
- Leverage existing `tests/` harness; add fixture that spawns reader+writer tasks exercising interleaving patterns.
- Validate index/query behavior by comparing results against a reference store (sqlite/postgres) for small workloads.
- benchmarks: Plan perf regression harness to compare with current single-writer flow; capture WAL size, latency, vacuum impact.
- Extend `bench` suite to toggle MVCC on/off and record metrics (allocations, cache hit ratio, page copies).
- Provide scripts that roll up benchmark outputs into Markdown summaries for release readiness.

## 7. Upgrade Path Considerations

- snapshot-ready: Record which components need only configuration/timestamp tweaks to reach snapshot isolation (e.g., allow multiple writers, introduce conflict detection).
- Identify blockers (writer arbitration, lock escalation) and tag them with effort estimates; this feeds future roadmap.
- Note compatibility requirements if we ever allow multi-writer WAL; helpful when scoping replication features.
- observability: Define metrics/logs that help validate MVCC readiness and future upgrades (oldest reader age, version counts, vacuum lag).
- Plan dashboards/alert thresholds so SREs can detect when version backlog threatens disk utilization.
- Include structured logs around commit lifecycle (begin/commit IDs) to aid debugging concurrency bugs in the field.
- rollout-plan: Outline deployment sequencing assuming format breakage (feature flag still useful, but expect users to rebuild or restore from backup).
- Describe bootstrap path for existing databases: e.g., require export/import or ship a one-shot upgrade tool instead of live backfill.
- Document rollback plan if MVCC feature flag misbehaves (disable flag, re-run checkpoint, optional vacuum).

### To-dos

- [x] Map current pager/concurrency semantics — call-flow + lock analysis captured in `docs/mvcc-baseline.md` §§1–4.
- [x] Publish pager/concurrency sequence diagrams — Mermaid flows added in `docs/mvcc-baseline.md` §11.
- [x] Trace storage layer mutation paths — flow table with owners/components for each mutation (`docs/mvcc-baseline.md` §6).
- [x] Summarize WAL+LSN behavior — free space analysis + metadata options logged in `docs/mvcc-baseline.md` §7.
- [x] Run WAL crash/replay validation — integration test `tests/integration/wal_crash_replay.rs` documents recovery path (`docs/mvcc-baseline.md` §12).
- [x] Design MVCC metadata format — schema document for the new layout (see `docs/mvcc-baseline.md` §8).
- [x] Define commit/visibility rules — spec for snapshot selection + failure handling (`docs/mvcc-baseline.md` §9).
- [x] Plan commit table + GC — data structure write-up and lifecycle (`docs/mvcc-baseline.md` §10).
- [x] Extend read snapshot handling — API changes + guard lifetime rules (`docs/mvcc-baseline.md` §13).
- [x] Plan pager copy-on-write path — decision doc on per-page COW plus counters (`docs/mvcc-baseline.md` §14).
- [x] Design page version chain+cleanup — ownership model + recovery behavior (`docs/mvcc-baseline.md` §14).
- [x] Update record encoders for MVCC — format bump + fuzz tests (`docs/mvcc-baseline.md` §15, `src/storage/{node,edge}.rs` proptests).
- [x] Scope index visibility updates — filtering helpers + deferred maintenance plan (`docs/mvcc-baseline.md` §16).
- [x] Adapt mutation paths to MVCC — API plumbing + invariants (`docs/mvcc-baseline.md` §17).
- [x] Plan reader tracking metrics — structure and export path (`docs/mvcc-baseline.md` §18).
- [x] Define vacuum + GC flow — worker pacing + checkpoint hooks (`docs/mvcc-baseline.md` §19).
- [x] Align checkpoint/WAL pruning — new state machine diagram (`docs/mvcc-baseline.md` §19.2).
- [x] Identify unit tests to add — matrix of pager/storage scenarios (`docs/mvcc-baseline.md` §20.1).
- [x] Plan end-to-end MVCC tests — concurrent workload descriptions (`docs/mvcc-baseline.md` §20.2).
- [x] Plan perf and regression runs — benchmark toggles + reporting scripts (`docs/mvcc-baseline.md` §20.3).
- [x] Document path to snapshot iso — list of delta requirements (`docs/mvcc-baseline.md` §21.1).
- [x] Define MVCC metrics/logging — metrics list + dashboards (`docs/mvcc-baseline.md` §21.2).
- [x] Outline deployment strategy — feature flag rollout + rollback steps (`docs/mvcc-baseline.md` §21.3).
